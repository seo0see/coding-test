# 예제 3-2. 큰 수의 법칙

# 입력받기
N, M, K = map(int, input().split()) # 배열의 크기 N, 숫자가 더해지는 횟수 M, 연속해서 더해질 수 있는 횟수 K
number = list(map(int, input().split()))
number.sort(reverse=True)
result = 0

while M > 0:
    if M-K>0:
        M -= K
        result += number[0]*K
        if M>0:
         M -= 1
         result += number[1]
    else:
         M -= M
         result += number[0]*M

print(result)


## input: 5 8 3 \n 2 4 5 4 6
## output: 46

## 단순하게 푸는 답안과 같은 형태.
##하지만 그 답안은 for문을 통해 K번 수를 더하도록 하였고, 수행 때마다 m을 조정하도록 함. 그리고 무한히 반복하도록 한 후 break와 if문을 통해 제어.
##나는 곱셈을 이용했고, 따라서 한 번에 M을 조정하도록 함. 그리고 M의 수로 제어.

## 단순하게 푸는 답안의 경우, M의 크기가 커지만 시간 초과 판정을 받기에, 수학적 아이디어를 통해 더 효율적으로 문제 해결
##가장 큰 수 K개, 두 번째로 큰 수로 구성된 (K+1)의 길이의 수열이 반복됨. M을 (K+1)로 나눈 몫이 수열이 반복되는 횟수. M이 (K+1)로 나누어떨어지지 않는 경우에는 M을 (K+1)로 나눈 나머지만큼 가장 큰 수가 더해짐.
##즉, 가장 큰 수가 더해지는 횟수는 int(M / (K + 1)) * K + M % (K + 1) 이고, 이를 이용해 두 번째로 큰 수가 더해지는 횟수까지 구할 수 있음.

## 답안 발상: 연속으로 더할 수 있는 횟수는 최대 K번이므로 '가장 큰 수를 K번 도하고 두 번째로 큰 수를 한 번 더하는 연산을 반복.