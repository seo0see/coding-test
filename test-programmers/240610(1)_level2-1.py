answer=[]

def move(n, start=1, end=3, temp=2): # n: 원판수, start: 시작 기둥, end: 끝 기둥, temp: 중간다리로 쓸 기둥
    if n == 1:
        answer.append([start, end])
    else:
        move(n-1, start, temp, end) # 가장 큰 원판 제외 1에서 2로 옮기기
        answer.append([start, end]) # 가장 큰 원판 1에서 3으로 옮기기
        move(n-1, temp, end, start) # 가장 큰 원판 제외 2에서 3으로 옮기기

def solution(n):
    # 이 상황 점화식으로 표현 가능.
    #(가장 큰 원판 제외 1에서 2로 옮기기 + 가장 큰 원판 1에서 3으로 옮기기 + 가장 큰 원판 제외 2에서 3으로 옮기기)
    
    move(n)
        
    return answer


# 테스트 13개 중 13개 통과
# 채점 결과
# 정확성: 100.0
# 합계: 100.0 / 100.0

## 상황이 점화식이라는 것은 파악했으나, 또 이것을 코드화 하게끔 하는 것을 생각하는 것이 오래 걸림.
## 상황이 어떻게 표현되는지, 그리고 그 표현을 잘 하기 위해 필요한 변수가 무엇인지 제대로 파악해내는 능력 필요.

## 가장 나와 유사한 다른 사람의 풀이 중에서는 처음부터 answer 리스트를 선언하지 않고, if문의 조건을 n==0인 경우로 하고,
## 'return hanoi(...)+[[start, end]]+hanoi(...)'로 하는 경우도 있음.
## 뭔가 메모리 차지를 덜 하고, 시간 절약도 할 수 있어보여 적어봄.

