## 다른 사람의 풀이 (나는 이것 계속 손대려다가, 멈칫멈칫하다가 못풂..ㅠ)
## 플로이드 워셜 알고리즘을 바탕으로 해결하는 풀이.
## 개인적으로는 비효율적일 것이라 생각해서 도전을 안했었는데, 우선 풀이를 해나가는 게 먼저일 듯.

import heapq

def solution(n, s, a, b, fares):
    d = [ [ 20000001 for _ in range(n) ] for _ in range(n) ]
    for x in range(n):
        d[x][x] = 0
    for x, y, c in fares:
        ## 양방향 모두 같은 비용을 가지니.
        d[x-1][y-1] = c
        d[y-1][x-1] = c

    ## 각 위치에서의 모든 최단거리 구하기.
    for i in range(n):
        for j in range(n):
            for k in range(n):
                if d[j][k] > d[j][i] + d[i][k]:
                    d[j][k] = d[j][i] + d[i][k]

    minv = 40000002
    for i in range(n):  
        minv = min(minv, d[s-1][i]+d[i][a-1]+d[i][b-1])
        ## 플로이드 워셜 알고리즘과 이 점화식 부분이 다름. (a,b로 가는 것도 생각해야하니)
    return minv


# 정확성: 50.0  (10개 중 10개 통과)
# 효율성: 50.0  (30개 중 30개 통과)
# 합계: 100.0 / 100.0

## 8번째 줄의 상수를 100001, 23번째 줄의 상수를 100002로 하면 이렇게 됨.
## 이렇게 했을 경우, 여기저기 지나가게 되어서 나오는 최단경로의 최대를 잘못 생각해서 그런 듯.
## 23번째 줄의 상수는 왜 그렇게 되는지(다른 것들을 다 통해 갔을 때의 최대의 수보다 커야 함) 알겠는데, 8번째 줄의 상수는 이유를 모르겠음.
# 채점 결과
# 정확성: 40.0  (10개 중 8개 통과)
# 효율성: 36.7  (30개 중 22개 통과)
# 합계: 76.7 / 100.0

